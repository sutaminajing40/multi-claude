#!/bin/bash

# 🚀 Multi-Claude システム起動・終了スクリプト
# 2つのターミナルウィンドウで完全なマルチエージェント環境を構築・終了

set -e

# バージョン情報
VERSION="1.3.2"

# 使用方法表示
show_usage() {
    cat << EOF
🤖 Multi-Claude システム

使用方法:
  $0           - システム起動（通常モード）
  $0 --exit    - システム完全終了
  $0 --help    - このヘルプを表示
  $0 --version - バージョン情報を表示
  $0 --dangerously-skip-permissions - 権限確認をスキップして起動（Claudeに--dangerously-skip-permissionsを付与）
  $0 --reset-terminal - ターミナル設定をリセット
  $0 "[指示]"  - PRESIDENTに直接指示を送信

機能:
  起動: tmux環境構築 + ターミナルウィンドウ起動 + Claude Code起動
  終了: 全tmuxセッション停止 + ターミナル閉鎖 + 一時ファイル削除
  指示: PRESIDENTセッションに直接メッセージを送信
EOF
}

# バージョン表示
show_version() {
    echo "Multi-Claude System v${VERSION}"
}

# 色付きログ関数
log_info() {
    echo -e "\033[1;32m[INFO]\033[0m $1"
}

log_success() {
    echo -e "\033[1;34m[SUCCESS]\033[0m $1"
}

log_error() {
    echo -e "\033[1;31m[ERROR]\033[0m $1"
}

# システム終了機能
exit_system() {
    echo "🛑 Multi-Claude システム終了中..."
    echo "================================="
    
    # STEP 1: tmuxセッション終了
    log_info "🔌 tmuxセッション終了中..."
    
    if tmux has-session -t multiagent 2>/dev/null; then
        tmux kill-session -t multiagent
        log_info "multiagentセッション終了"
    fi
    
    if tmux has-session -t president 2>/dev/null; then
        tmux kill-session -t president  
        log_info "presidentセッション終了"
    fi
    
    # 他のmulti-claude関連セッションも終了
    tmux list-sessions 2>/dev/null | grep -E "(multiagent|president)" | cut -d: -f1 | xargs -I {} tmux kill-session -t {} 2>/dev/null || true
    
    # STEP 2: 一時ファイル削除
    log_info "🧹 一時ファイル削除中..."
    rm -f "$MULTI_CLAUDE_LOCAL/tmp/worker*_done.txt" 2>/dev/null || true
    rm -rf "$MULTI_CLAUDE_LOCAL/tmp" 2>/dev/null || true
    rm -rf "$MULTI_CLAUDE_LOCAL/logs" 2>/dev/null || true
    rm -rf "$MULTI_CLAUDE_LOCAL/context" 2>/dev/null || true
    rm -rf "$MULTI_CLAUDE_LOCAL/tasks" 2>/dev/null || true
    
    # STEP 3: ターミナルウィンドウ閉鎖（macOSのみ）
    if [[ "$OSTYPE" == "darwin"* ]]; then
        log_info "🪟 ターミナルウィンドウ閉鎖中..."
        # 設定されたターミナルアプリのセッション閉鎖
        CONFIG_DIR="$HOME/.multi-claude"
        CONFIG_FILE="$CONFIG_DIR/config"
        
        # 設定を読み込み
        if [ -f "$CONFIG_FILE" ]; then
            source "$CONFIG_FILE"
        fi
        
        if [ "$TERMINAL_APP" = "iTerm" ]; then
            # iTerm2のセッション閉鎖
            osascript << 'EOL' 2>/dev/null || true
tell application "iTerm2"
    repeat with w in windows
        tell w
            repeat with t in tabs
                tell t
                    repeat with s in sessions
                        if name of s contains "Multi-Claude" then
                            close s
                        end if
                    end repeat
                end tell
            end repeat
        end tell
    end repeat
end tell
EOL
        else
            # 標準ターミナルの閉鎖
            osascript << 'EOL' 2>/dev/null || true
tell application "Terminal"
    repeat with w in windows
        repeat with t in tabs of w
            if name of t contains "Multi-Claude" then
                close t
            end if
        end repeat
    end repeat
end tell
EOL
        fi
    fi
    
    log_success "✅ Multi-Claude システム完全終了"
    echo ""
    echo "👋 お疲れさまでした！"
    exit 0
}

# 権限スキップフラグと直接指示
SKIP_PERMISSIONS=""
DIRECT_MESSAGE=""

# コマンドライン引数処理
case "${1:-}" in
    --exit)
        exit_system
        ;;
    --help|-h)
        show_usage
        exit 0
        ;;
    --version|-v)
        show_version
        exit 0
        ;;
    --reset-terminal)
        # ターミナル設定をリセット
        CONFIG_DIR="$HOME/.multi-claude"
        CONFIG_FILE="$CONFIG_DIR/config"
        if [ -f "$CONFIG_FILE" ]; then
            rm "$CONFIG_FILE"
            log_success "✓ ターミナル設定をリセットしました"
            echo "次回起動時にターミナルを選択できます。"
        else
            log_info "ターミナル設定はまだ保存されていません"
        fi
        exit 0
        ;;
    --dangerously-skip-permissions)
        SKIP_PERMISSIONS="--dangerously-skip-permissions"
        ;;
    "")
        # 通常起動（既存処理）
        ;;
    --*)
        echo "❌ 不明なオプション: $1"
        show_usage
        exit 1
        ;;
    *)
        # 直接指示として扱う
        DIRECT_MESSAGE="$1"
        ;;
esac

echo "🤖 Multi-Claude システム起動"
echo "============================="
echo ""

# 現在のディレクトリ取得
CURRENT_DIR=$(pwd)

# Homebrewからのインストールを検出
BREW_PREFIX="$(brew --prefix 2>/dev/null || echo '/usr/local')"
if [ -d "${BREW_PREFIX}/Cellar/multi-claude" ]; then
    # Homebrew経由でインストールされた場合
    # 最新バージョンのディレクトリを取得
    MULTI_CLAUDE_VERSION=$(ls -1 "${BREW_PREFIX}/Cellar/multi-claude" | sort -V | tail -1)
    MULTI_CLAUDE_BASE="${BREW_PREFIX}/Cellar/multi-claude/${MULTI_CLAUDE_VERSION}"
    MULTI_CLAUDE_BIN="${MULTI_CLAUDE_BASE}/bin"
    MULTI_CLAUDE_SHARE="${MULTI_CLAUDE_BASE}/share"
else
    # ローカル実行の場合
    MULTI_CLAUDE_BASE=""
    MULTI_CLAUDE_BIN=""
    MULTI_CLAUDE_SHARE=""
fi

# グローバルパス設定（早期に設定）
if [ -n "$MULTI_CLAUDE_BASE" ] && [ -d "$MULTI_CLAUDE_BASE" ]; then
    # Homebrewインストールの場合
    export MULTI_CLAUDE_GLOBAL="$MULTI_CLAUDE_BASE"
elif [ -d "$HOME/.multi-claude" ]; then
    # install.shインストールの場合
    export MULTI_CLAUDE_GLOBAL="$HOME/.multi-claude"
else
    # ローカル実行の場合
    export MULTI_CLAUDE_GLOBAL="$(pwd)"
fi

# ローカルパス設定
export MULTI_CLAUDE_LOCAL="$(pwd)/.multi-claude"

# 初回セットアップ関数
setup_first_time() {
    log_info "🎯 初回セットアップを実行します..."
    
    # ローカルディレクトリ作成（プロジェクト固有データ用）
    mkdir -p "$MULTI_CLAUDE_LOCAL/session/tmp"
    mkdir -p "$MULTI_CLAUDE_LOCAL/session/logs"
    mkdir -p "$MULTI_CLAUDE_LOCAL/session/runtime"
    mkdir -p "$MULTI_CLAUDE_LOCAL/context"
    mkdir -p "$MULTI_CLAUDE_LOCAL/tasks"
    mkdir -p "$MULTI_CLAUDE_LOCAL/config"
    mkdir -p "$MULTI_CLAUDE_LOCAL/instructions"
    
    # CLAUDE.mdの処理（既存ファイルを保持）
    CLAUDE_TEMPLATE_PATH=""
    if [ -n "$MULTI_CLAUDE_SHARE" ]; then
        CLAUDE_TEMPLATE_PATH="${MULTI_CLAUDE_SHARE}/CLAUDE_template.md"
    elif [ -f "$HOME/.multi-claude/share/CLAUDE_template.md" ]; then
        CLAUDE_TEMPLATE_PATH="$HOME/.multi-claude/share/CLAUDE_template.md"
    elif [ -f "$MULTI_CLAUDE_GLOBAL/share/CLAUDE_template.md" ]; then
        CLAUDE_TEMPLATE_PATH="$MULTI_CLAUDE_GLOBAL/share/CLAUDE_template.md"
    fi
    
    if [ -n "$CLAUDE_TEMPLATE_PATH" ]; then
        log_info "CLAUDE_template.mdを検出: $CLAUDE_TEMPLATE_PATH"
        if [ -f "./CLAUDE.md" ]; then
            # 既存のCLAUDE.mdがある場合、Multi-Claudeシステム設定を追加
            log_info "既存のCLAUDE.mdにMulti-Claudeシステム設定を追加中..."
            
            # システム設定が既に追加されているかチェック
            if ! grep -q "## 🤖 Multi-Claude システム設定" "./CLAUDE.md"; then
                # 既存の内容を一時保存
                cp "./CLAUDE.md" "./CLAUDE.md.original"
                
                # Multi-Claudeシステム設定を先頭に追加（プレースホルダーを置き換え）
                sed -e "s|\[STARTUP_TIME\]|$(date '+%Y-%m-%d %H:%M:%S')|g" \
                    -e "s|\[PROJECT_PATH\]|$(pwd)|g" \
                    -e "s|\[GLOBAL_PATH\]|$MULTI_CLAUDE_GLOBAL|g" \
                    -e "s|\[LOCAL_PATH\]|$MULTI_CLAUDE_LOCAL|g" \
                    "$CLAUDE_TEMPLATE_PATH" > "./CLAUDE.md.tmp"
                echo "" >> "./CLAUDE.md.tmp"
                echo "---" >> "./CLAUDE.md.tmp"
                echo "" >> "./CLAUDE.md.tmp"
                echo "# 元のCLAUDE.md内容" >> "./CLAUDE.md.tmp"
                echo "" >> "./CLAUDE.md.tmp"
                cat "./CLAUDE.md.original" >> "./CLAUDE.md.tmp"
                
                # 新しいCLAUDE.mdとして保存
                mv "./CLAUDE.md.tmp" "./CLAUDE.md"
                rm "./CLAUDE.md.original"
                
                log_success "✅ 既存のCLAUDE.mdを保持しつつ、システム設定を追加しました"
            else
                log_info "Multi-Claudeシステム設定は既に追加されています"
            fi
        else
            # CLAUDE.mdがない場合は新規作成（プレースホルダーを置き換え）
            log_info "CLAUDE.mdを作成中..."
            sed -e "s|\[STARTUP_TIME\]|$(date '+%Y-%m-%d %H:%M:%S')|g" \
                -e "s|\[PROJECT_PATH\]|$(pwd)|g" \
                -e "s|\[GLOBAL_PATH\]|$MULTI_CLAUDE_GLOBAL|g" \
                -e "s|\[LOCAL_PATH\]|$MULTI_CLAUDE_LOCAL|g" \
                "$CLAUDE_TEMPLATE_PATH" > "./CLAUDE.md"
        fi
    else
        log_error "CLAUDE_template.mdが見つかりません"
        log_info "  検索パス:"
        log_info "  - $HOME/.multi-claude/share/CLAUDE_template.md"
        log_info "  - $MULTI_CLAUDE_GLOBAL/share/CLAUDE_template.md"
    fi
    
    # 指示書ファイルをローカルにコピー
    log_info "指示書ファイルをローカルにコピー中..."
    if [ -d "$MULTI_CLAUDE_GLOBAL/instructions" ]; then
        cp "$MULTI_CLAUDE_GLOBAL/instructions/president_dynamic.md" "$MULTI_CLAUDE_LOCAL/instructions/" 2>/dev/null || true
        cp "$MULTI_CLAUDE_GLOBAL/instructions/boss_dynamic.md" "$MULTI_CLAUDE_LOCAL/instructions/" 2>/dev/null || true
        cp "$MULTI_CLAUDE_GLOBAL/instructions/worker_dynamic.md" "$MULTI_CLAUDE_LOCAL/instructions/" 2>/dev/null || true
        log_success "✅ 指示書ファイルをコピーしました"
    else
        log_error "グローバル指示書ディレクトリが見つかりません: $MULTI_CLAUDE_GLOBAL/instructions"
    fi
    
    log_success "✅ 初回セットアップ完了"
}

# STEP 0: 初回セットアップチェック
# ローカルディレクトリが存在しない場合のみセットアップ
if [ ! -d "$MULTI_CLAUDE_LOCAL/session" ] || [ ! -f "./CLAUDE.md" ]; then
    setup_first_time
fi

# STEP 1: 環境チェック
log_info "🔍 環境チェック中..."

# tmuxの存在確認
if ! command -v tmux &> /dev/null; then
    log_error "tmuxがインストールされていません"
    echo "インストール: brew install tmux"
    exit 1
fi

# Homebrewから実行される場合のPATH調整
# ユーザーのホームディレクトリ内のバイナリパスを追加
export PATH="$HOME/.claude/local:$HOME/.local/bin:$HOME/bin:/usr/local/bin:/opt/homebrew/bin:$PATH"

# claudeコマンドの検出（改善版）
CLAUDE_CMD=""

# 1. 直接パスを最優先で確認
if [ -x "$HOME/.claude/local/claude" ]; then
    CLAUDE_CMD="$HOME/.claude/local/claude"
    log_info "🔍 claudeを検出: $CLAUDE_CMD"
# 2. PATHからclaudeを検索（which使用）
elif which claude >/dev/null 2>&1; then
    CLAUDE_CMD=$(which claude 2>/dev/null)
    log_info "🔍 claudeを検出: $CLAUDE_CMD"
# 3. command -vでも試す（bashビルトイン）
elif command -v claude >/dev/null 2>&1; then
    CLAUDE_CMD="claude"
    log_info "🔍 claudeを検出: command -v claude"
# 4. claude-codeやclaude.codeなどのバリエーションも確認
else
    for cmd in claude-code claude.code; do
        if which $cmd >/dev/null 2>&1; then
            CLAUDE_CMD=$(which $cmd 2>/dev/null)
            log_info "🔍 claudeを検出: $CLAUDE_CMD"
            break
        fi
    done
fi

# 見つからない場合のみエラー
if [ -z "$CLAUDE_CMD" ]; then
    log_error "claude commandが見つかりません"
    echo "Claude Codeがインストールされていることを確認してください"
    
    # claude実行ファイルの検索を試みる
    echo ""
    echo "📍 claudeコマンドを検索中..."
    CLAUDE_PATHS=$(find "$HOME" -name "claude*" -type f -perm +111 2>/dev/null | grep -E "(bin|\.local|\.claude)" | head -5)
    if [ -n "$CLAUDE_PATHS" ]; then
        echo "以下の場所で見つかりました:"
        echo "$CLAUDE_PATHS"
        echo ""
        echo "PATHに追加するには:"
        echo "export PATH=\"\$(dirname \$(echo '$CLAUDE_PATHS' | head -1)):\$PATH\""
    fi
    exit 1
fi

log_success "✅ 環境チェック完了"

# STEP 2: tmux環境構築
log_info "🏗️  tmux環境構築中..."

# グローバルパスからsetup.shを実行
SETUP_SCRIPT=""
if [ -f "$MULTI_CLAUDE_GLOBAL/bin/setup.sh" ]; then
    SETUP_SCRIPT="$MULTI_CLAUDE_GLOBAL/bin/setup.sh"
elif [ -f "$MULTI_CLAUDE_GLOBAL/setup.sh" ]; then
    SETUP_SCRIPT="$MULTI_CLAUDE_GLOBAL/setup.sh"
elif [ -f "./setup.sh" ]; then
    # ローカル実行の場合
    SETUP_SCRIPT="./setup.sh"
else
    log_error "setup.shが見つかりません"
    echo "インストールが正しく完了していない可能性があります"
    exit 1
fi

# setup.sh実行
$SETUP_SCRIPT || {
    log_error "setup.shの実行に失敗しました"
    exit 1
}

# tmuxセッション作成の確認
sleep 1
if ! tmux has-session -t multiagent 2>/dev/null; then
    log_error "multiagentセッション作成に失敗しました"
    exit 1
fi
if ! tmux has-session -t president 2>/dev/null; then
    log_error "presidentセッション作成に失敗しました"
    exit 1
fi
log_info "✅ tmuxセッション作成を確認"

# STEP 3: ターミナルウィンドウ起動
log_info "💻 MULTIAGENTターミナルウィンドウ起動中..."

# 設定ファイルのパス
CONFIG_DIR="$HOME/.multi-claude"
CONFIG_FILE="$CONFIG_DIR/config"

# 設定ディレクトリが存在しない場合は作成
if [ ! -d "$CONFIG_DIR" ]; then
    mkdir -p "$CONFIG_DIR"
fi

# ターミナルアプリの設定を読み込み
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

# OSの検出
if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS
    # ターミナルアプリが設定されていない場合は選択を促す
    if [ -z "$TERMINAL_APP" ]; then
        echo ""
        echo "🖥  使用するターミナルアプリを選択してください:"
        echo "1) Terminal (標準ターミナル)"
        echo "2) iTerm2"
        echo ""
        read -p "選択 (1 または 2): " choice
        
        case $choice in
            1)
                TERMINAL_APP="Terminal"
                ;;
            2)
                # iTerm2がインストールされているか確認
                if osascript -e 'tell application "System Events" to name of application processes' 2>/dev/null | grep -q "iTerm"; then
                    TERMINAL_APP="iTerm"
                else
                    echo ""
                    log_error "iTerm2がインストールされていません。標準ターミナルを使用します。"
                    TERMINAL_APP="Terminal"
                    sleep 2
                fi
                ;;
            *)
                echo "無効な選択です。標準ターミナルを使用します。"
                TERMINAL_APP="Terminal"
                ;;
        esac
        
        # 設定を保存
        echo "TERMINAL_APP=\"$TERMINAL_APP\"" > "$CONFIG_FILE"
        echo ""
        log_success "設定を保存しました: $TERMINAL_APP"
        echo ""
    fi
    
    # MULTIAGENT用ターミナルのみ作成
    # PRESIDENT用は現在のターミナルを使用
    if [ "$TERMINAL_APP" = "iTerm" ]; then
        # iTerm2を使用 - 新しいタブで開く
        osascript << EOF 2>/dev/null
tell application "iTerm"
    tell current window
        create tab with default profile
        tell current tab
            tell current session
                write text "cd '$CURRENT_DIR' && echo '👥 MULTIAGENT ウィンドウ' && tmux attach-session -t multiagent"
                set name to "Multi-Claude: MULTIAGENT"
            end tell
        end tell
    end tell
end tell
EOF
    else
        # 標準ターミナルを使用
        osascript << EOF 2>/dev/null
tell application "Terminal"
    do script "cd '$CURRENT_DIR' && echo '👥 MULTIAGENT ウィンドウ' && tmux attach-session -t multiagent"
    delay 1
    set currentWindow to front window
    set currentTab to selected tab of currentWindow
    try
        tell currentTab
            set custom title to "Multi-Claude: MULTIAGENT"
        end tell
    on error
        -- タイトル設定エラーは無視
    end try
end tell
EOF
    fi
    
    if [ $? -ne 0 ]; then
        log_error "MULTIAGENTウィンドウの起動に失敗しました"
        echo "手動でターミナルを開いて以下を実行してください:"
        echo "tmux attach-session -t multiagent"
        exit 1
    fi

elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
    # Linux - MULTIAGENT用ターミナルのみ作成
    if command -v gnome-terminal &> /dev/null; then
        # GNOME Terminal
        gnome-terminal --title="Multi-Claude: MULTIAGENT" -- bash -c "cd '$CURRENT_DIR' && echo '👥 MULTIAGENT ウィンドウ' && tmux attach-session -t multiagent; exec bash" &
    elif command -v xterm &> /dev/null; then
        # xterm
        xterm -title "Multi-Claude: MULTIAGENT" -e "cd '$CURRENT_DIR' && echo '👥 MULTIAGENT ウィンドウ' && tmux attach-session -t multiagent" &
    else
        log_error "対応するターミナルが見つかりません"
        exit 1
    fi
else
    log_error "対応していないOS: $OSTYPE"
    exit 1
fi

log_success "✅ MULTIAGENTターミナルウィンドウ起動完了"

# STEP 3.5: 環境変数確認
log_info "🔧 環境変数設定完了..."
log_info "  MULTI_CLAUDE_GLOBAL: $MULTI_CLAUDE_GLOBAL"
log_info "  MULTI_CLAUDE_LOCAL: $MULTI_CLAUDE_LOCAL"

# STEP 4: Claude Code自動起動と初期タスク確認
log_info "⏳ Claude Code起動準備中..."
sleep 3
log_info "🤖 Claude Code自動起動中..."

# MULTIAGENT起動（全ペイン）
for i in {0..3}; do
    case $i in
        0) agent_name="boss1" ;;
        1) agent_name="worker1" ;;
        2) agent_name="worker2" ;;
        3) agent_name="worker3" ;;
    esac
    log_info "🤖 $agent_name 起動中..."
    # 環境変数を設定してからClaude Codeを起動
    tmux send-keys -t multiagent:0.$i "export MULTI_CLAUDE_LOCAL='$MULTI_CLAUDE_LOCAL'" C-m
    tmux send-keys -t multiagent:0.$i "export MULTI_CLAUDE_GLOBAL='$MULTI_CLAUDE_GLOBAL'" C-m
    if ! tmux send-keys -t multiagent:0.$i "$CLAUDE_CMD $SKIP_PERMISSIONS" C-m; then
        log_error "$agent_name へのClaude Code起動コマンド送信に失敗"
        exit 1
    fi
    sleep 2
done

log_success "✅ Claude Code起動完了"

# エージェントに役割を認識させる初期メッセージを送信
log_info "⏳ Claude Codeの起動を待機中..."
sleep 5  # Claude Codeが完全に起動するまで待機
log_info "🤖 エージェントに役割を認識させています..."
tmux send-keys -t multiagent:0.0 "あなたはboss1です。CLAUDE.mdと$MULTI_CLAUDE_LOCAL/instructions/boss_dynamic.mdを読み込んで、指示に従って行動してください。" C-m
tmux send-keys -t multiagent:0.1 "あなたはworker1です。CLAUDE.mdと$MULTI_CLAUDE_LOCAL/instructions/worker_dynamic.mdを読み込んで、指示に従って行動してください。" C-m
tmux send-keys -t multiagent:0.2 "あなたはworker2です。CLAUDE.mdと$MULTI_CLAUDE_LOCAL/instructions/worker_dynamic.mdを読み込んで、指示に従って行動してください。" C-m
tmux send-keys -t multiagent:0.3 "あなたはworker3です。CLAUDE.mdと$MULTI_CLAUDE_LOCAL/instructions/worker_dynamic.mdを読み込んで、指示に従って行動してください。" C-m

# STEP 4.5: システム起動確認とタスクチェック
log_info "🔄 システム起動確認中..."
sleep 3

# 各エージェントに起動確認メッセージを送信
log_info "📡 エージェント間通信テスト中..."

# システム起動確認ファイルを作成
mkdir -p "$MULTI_CLAUDE_LOCAL/tasks"
echo "Multi-Claude System Started at $(date)" > "$MULTI_CLAUDE_LOCAL/tasks/system_status.txt"

# 前回のタスク状態をチェック
if [ -f "$MULTI_CLAUDE_LOCAL/tasks/current_task.md" ]; then
    log_info "📋 前回の未完了タスクを検出しました"
    echo ""
    echo "===== 未完了タスク ====="
    head -5 "$MULTI_CLAUDE_LOCAL/tasks/current_task.md"
    echo "========================"
    echo ""
    
    # PRESIDENTに未完了タスクの確認を促す
    sleep 2
    if [ -f "$MULTI_CLAUDE_GLOBAL/bin/agent-send.sh" ]; then
        $MULTI_CLAUDE_GLOBAL/bin/agent-send.sh president "システムが起動しました。前回の未完了タスクがあります。$MULTI_CLAUDE_LOCAL/tasks/current_task.mdを確認してください。"
    elif [ -f "$MULTI_CLAUDE_GLOBAL/agent-send.sh" ]; then
        $MULTI_CLAUDE_GLOBAL/agent-send.sh president "システムが起動しました。前回の未完了タスクがあります。$MULTI_CLAUDE_LOCAL/tasks/current_task.mdを確認してください。"
    fi
fi

log_success "✅ システム起動確認完了"

# STEP 5: 直接指示の送信（オプション）
if [ -n "$DIRECT_MESSAGE" ]; then
    log_info "📨 PRESIDENTへ直接指示を送信中..."
    sleep 2
    
    # agent-send.shを使用してメッセージ送信
    if [ -f "$MULTI_CLAUDE_GLOBAL/bin/agent-send.sh" ]; then
        $MULTI_CLAUDE_GLOBAL/bin/agent-send.sh president "$DIRECT_MESSAGE"
    elif [ -f "$MULTI_CLAUDE_GLOBAL/agent-send.sh" ]; then
        $MULTI_CLAUDE_GLOBAL/agent-send.sh president "$DIRECT_MESSAGE"
    else
        log_error "agent-send.shが見つかりません"
        exit 1
    fi
    
    log_success "✅ 指示を送信しました"
    
    # PRESIDENTセッションにアタッチ
    echo ""
    echo "🔍 PRESIDENTセッションに接続中..."
    echo "   終了するには: Ctrl+B → D"
    sleep 2
    tmux attach-session -t president
else
    echo ""
    echo "🎉 Multi-Claude システム起動完了！"
    echo "=================================="
    echo ""
    echo "📋 使用方法:"
    echo "  1. 🎯 現在のターミナル: PRESIDENT（メインの対話窓口）"
    echo "  2. 👥 MULTIAGENTウィンドウ: BOSS+WORKERs監視用"
    echo ""
    echo "💬 PRESIDENTに話しかけてタスクを依頼してください："
    echo "     例: 「Pythonスクリプトを3人で作って」"
    echo ""
    echo "💡 直接指示も可能:"
    echo "     multi-claude \"Pythonで計算機を作って\""
    echo ""
    echo "🔧 システム制御:"
    echo "  終了: Ctrl+C でClaude終了、tmux kill-server で完全リセット"
    echo "  再起動: multi-claude"
    echo ""
    
    # PRESIDENTターミナルウィンドウを起動
    echo "🤖 PRESIDENTウィンドウを起動中..."
    echo "   MULTIAGENTウィンドウとPRESIDENTウィンドウで監視可能です"
    sleep 2
    
    # presidentセッションで環境変数を設定してClaude Codeを起動
    tmux send-keys -t president:0 "export MULTI_CLAUDE_LOCAL='$MULTI_CLAUDE_LOCAL'" C-m
    tmux send-keys -t president:0 "export MULTI_CLAUDE_GLOBAL='$MULTI_CLAUDE_GLOBAL'" C-m
    tmux send-keys -t president:0 "$CLAUDE_CMD $SKIP_PERMISSIONS" C-m
    
    # CLAUDE.mdの存在を確認するメッセージを送信（起動完了後）
    sleep 5  # Claude Codeが完全に起動するまで待機
    tmux send-keys -t president:0 "あなたはPRESIDENTです。まず、CLAUDE.mdと$MULTI_CLAUDE_LOCAL/instructions/president_dynamic.mdを読み込んで、指示に従って行動してください。" C-m
    
    # PRESIDENT用ターミナルを別タブで起動
    if [ "$TERMINAL_APP" = "iTerm" ]; then
        # iTerm2を使用 - 新しいタブで開く
        osascript << EOF 2>/dev/null
tell application "iTerm"
    tell current window
        create tab with default profile
        tell current tab
            tell current session
                write text "cd '$CURRENT_DIR' && echo '👑 PRESIDENT ウィンドウ' && tmux attach-session -t president"
                set name to "Multi-Claude: PRESIDENT"
            end tell
        end tell
    end tell
end tell
EOF
    else
        # 標準ターミナルを使用
        osascript << EOF 2>/dev/null
tell application "Terminal"
    do script "cd '$CURRENT_DIR' && echo '👑 PRESIDENT ウィンドウ' && tmux attach-session -t president"
    delay 1
    set currentWindow to front window
    set currentTab to selected tab of currentWindow
    try
        tell currentTab
            set custom title to "Multi-Claude: PRESIDENT"
        end tell
    on error
        -- タイトル設定エラーは無視
    end try
end tell
EOF
    fi
    
    echo ""
    echo "✅ 2つのウィンドウが起動しました："
    echo "   1. MULTIAGENT (boss1 + worker1,2,3)"
    echo "   2. PRESIDENT (メインの対話窓口)"
    echo ""
    echo "💡 ヒント: 各ウィンドウで作業状況を確認できます"
fi